# Algorithm - DP(Dynamic Programming)

동적 계획법 Dynamic Programming의 조건은 두 가지가 있다.이는 바로 **최적 부분 구조(Optimal Substructure), 중복되는 부분 문제(Overlapping Subproblems)** 이다.

## 최적 부분 구조

최적 부분 구조가 있다는 것은 -> 부분 문제들의 최적의 답을 이용해서 기존 문제의 최적의 답을 구할 수 있다는 것을 의미한다.

fib(5)를 구하려면, fib(4)와 fib(3)을 구하는 부분 문제를 먼저 해결해야 한다. 이 점에서, 피보나치는 최적 부분 구조를 갖고 있다.

## 중복되는 부분 문제

재귀 함수 -> 부분문제 를 봤었음. fib(5)를 해결하기 위해 fib(4)와 fib(3)이라는 부분문제를, fib(4)를 해결하기 위해 fib(3)과 fib(2)를 구해야 한다. fib(3)을 구하기 위해 fib(2)와 fib(1)을 구해야 하는데, 이 두개는 고정된 값이므로 여기서부터 시작한다. 이 경우를 보면, 중복되는 부분 문제가 있다. (fib(3)을 두번 계산). fib(7)을 구하는 과정에서 fib(5), fib(4), fib(3)을 여러 번 계산해야 한다. 이는 중복되는 부분 문제로, 이는 매우 비효율적이다. 이를 해결하는 게 DP(Dynamic Programming)이다.

합병 정렬을 보자. `merge-sort` = ([16, 11, 6, 13, 1, 4, 10, 7])이 있다고 해보자. 이를 4개짜리 리스트 [16, 11, 6, 13], [1, 4, 10, 7]로 나눈다. 이후 이를 또다시 합병 정렬을 한다. 이 두 가지를 해결하는 과정은, 겹치는 게 없는 완전히 독립적이다. 즉 중복되지 않는 부분문제(Non-Overlapping Subproblem)이다.

## Dynamic Programming

어떤 문제에 대해 최적 부분 구조가 있다는 것은 -> 부분 문제들의 최적의 답을 이용해서 기존 문제의 최적의 답을 구할 수 있다는 것을 의미한다. 즉 기존 문제를 부분 문제로 나눠서 풀 수 있다. 근데 이럴 때 중복되는 부분 문제들이 있을 수 있다. 이 경우 똑같은 문제를 여러 번 풀어야 한다는 비효율성이 발생한다. 이런 비효율을 해결하는 알고리즘이 DP이다.

1. 최적 부분 구조가 있고,
2. 중복되는 부분 문제들이 있을 경우

-> DP로 문제를 해결한다.

DP를 간단하게 설명하면, **한 번 계산한 결과를 재활용하는 방식**이다. 그러니까, 중복되는 문제를 한 번만 풀고 기억해두는 것이다. 피보나치를 예로 들면, fib(7)를 구하기 위해 fib(6), fib(5), fib(4), fib(3)을 여러 번 계산해야 되는데, 이를 한 번씩만 계산하게 한 것이다.

DP를 구현하는 방법은 `Memoization`, `Tabulation`의 두 가지로 나뉜다.

### Memoization

카페 손님이 아메리카노, 치즈케익, 와플을 시키는 경우가 많다고 해 보자. 각각 4300원, 5100원, 4800원이다. 근데 매번 주문받을 때마다 이 세 가격을 더해야 됐기 때문에 매우 불편했다. 그래서, 이 세 개를 더한 값을 메모해두기로 했다. 그 이후 주문받기가 굉장히 쉬워졌다.

이런 예시처럼, 중복되는 계산은 한 번만 계산한 후 메모하고 이후에는 메모를 참고하는 방식을 **Memoization**이라고 한다.

피보나치 수에 적용시켜보자. 옆에 `cache`(다시 쓸 값을 저장해두는 공간)를 두자. fib(6)을 구하기 위해 fib(5), fib(4)를, 그리고 fib(4)를 구하려면 fib(3), fib(2)를, 그리고 fib(3)을 구하려면 fib(2)와 fib(1)라는 각각의 부분 문제를 전부 해결해야 한다.

fib(2)와 fib(1)은 base case이므로 답을 바로 알 수 있다. 그치만 나중에 또 쓸 수도 있으므로 이를 cache에 기록해두자(1 -> 1, 2 -> 1). 이제 이 두 가지를 통해 fib(3)을 구할 수 있으므로 이또한 cache에 기록해 두자(3 -> 2). 이후 fib(4)를 구하기 위해 fib(3)과 fib(2)를 알아야 하는데, 이는 다시 계산할 필요 없이 그냥 cache에서 가져다 쓰면 된다. 이제 fib(4)도 계산할 수 있다. fib(4) = 3인데, 이 또한 cache에 기록해 두자(4 -> 3). 이런 식으로 fib(5) -> 5, fib(6) -> 8로 전부 cache에 기록된 것을 갖다 쓰기만 하면 해결이 된다.

### Tabulation

Memoization에서는 fib(6)을 구하기 위해 fib(5)와 fib(4)를, fib(5)를 구하기 위해 fib(4)와 fib(3)을, ... 이런 식으로 위에서부터 내려가는 하향식 접근(top-down approach)을 했었다.

반대로 fib(1)을 구한 후 fib(2), fib(3), ... fib(6)의 순서대로 구하는 것을 상향식 접근 (bottom-up approach)이라 한다.

fib(1) = 1, fib(2) = 1이고, fib(3)은 fib(1)과 fib(2)를 더해서 2, fib(4)는 fib(3)과 fib(2)를 더해서 3, .. 이런식으로 fib(6)을 구하면 8이 된다. 표를 영어로 table인데, Tabulation은 테이블 형식으로 정리한다는 의미에서 이렇게 불린다.

Memoization은 재귀 형태로 구하는 것인 반면에 Tabulation은 반복문 형태로 구하는 것이라는 점에서 차이가 있다.

## Memoization vs. Tabulation

공통점은, 둘 다 중복되는 부분 문제의 비효율을 해결해준다는 것이다. 가장 핵심적인 차이점이 있다면, `Memoization`은 재귀함수를 사용하고, `Tabulation은` 반복문을 사용한다는 것이다. `Memoization`을 사용하면 재귀함수를 불러와야 하는데, 너무 많이 쌓이면 호출 스택이 계속 쌓이고, 결국에 과부하가 걸려서 오류가 날 수도 있다. 반면에 `Tabulation`을 사용하면 그런 위험이 날 일은 없다. `Tabulation`은 표를 하나씩 채워가는 것이기 때문에 n번째 값을 구하기 위해서 처음부터 모두 계산한다. 그래서 어쩌면 중간에 필요없는 것들까지 계산하게 될 수도 있다. 반면에 `Memoization`은 위에서부터 필요한 계산을 요구하는 형식이라서 필요없는 계산은 안 해도 된다는 장점이 있다.

## DP 공간 최적화

Tabulation으로 피보나치 함수를 풀어봤는데, 이 방식을 사용하면 시간 복잡도, 공간 복잡도 모두 `O(n)`이다. DP를 사용해서 훨씬 효율적인 코드가 되었다. 그러나 아직도 비효율적인 부분이 좀 있다. fib(5)를 구하기 위해 fib(4)와 fib(3)만 알면 된다. 마찬가지로 fib(20)도 fib(19)와 fib(18)만 알면 된다. 그러나 우리는 20에 도달하기 위한 18, 19의 필요 요소들 까지 전부 리스트에 저장해 두고 있다.(즉 n이 1부터 17까지의 fib(n)) 이것을 더 효율적으로 하기 위해 리스트 대신 가장 최근 값을 저장하는 변수 두 개를 사용하면 된다. 예를 들어 가장 최근값을 나타내는 `current`와 직전 값을 나타내는 `previous`가 있다. 기존의 `previous`와 기존의` current`를 더한 값이 변수` current`에 들어가고, 기존의 `current` 값이 `previous`로 들어가면 된다. 이런 식으로 구하면 된다. 사용하는 메모리는 고정되어있기 때문에 (current, previous) 공간 복잡도는 `O(1)`이다.

앞으로 DP를 풀 때 모든 값을 저장할 필요가 없는 경우에는 이런 식의 공간 최적화를 고려해보면 좋을 것이다.
